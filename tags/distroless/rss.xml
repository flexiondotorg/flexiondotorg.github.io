<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Distroless on Wimpy's World</title><link>https://wimpysworld.com/tags/distroless/</link><description>Recent content in Distroless on Wimpy's World</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><managingEditor>martin@wimpress.com (Martin Wimpress)</managingEditor><webMaster>martin@wimpress.com (Martin Wimpress)</webMaster><lastBuildDate>Fri, 18 Jun 2021 12:18:15 +0000</lastBuildDate><atom:link href="https://wimpysworld.com/tags/distroless/rss.xml" rel="self" type="application/rss+xml"/><item><title>Creating Production-Ready Containers - Advanced Techniques</title><link>https://wimpysworld.com/posts/creating-production-ready-containers-advanced-techniques/</link><pubDate>Fri, 18 Jun 2021 12:18:15 +0000</pubDate><author>martin@wimpress.com (Martin Wimpress)</author><guid>https://wimpysworld.com/posts/creating-production-ready-containers-advanced-techniques/</guid><description>&lt;p>Creating production-ready containers for use in commercial-grade apps can be a far cry from the &amp;ldquo;get started with Node.js and Docker&amp;rdquo;-type of tutorials that are common around the Internet. Those guides are great for introducing all the advantages of Docker containers in modern cloud-native development, but creating a container that passes muster in a large-scale application in production is a different story.&lt;/p>
&lt;p>For production-ready containers, there are three key things you want to optimise for when creating a container:&lt;/p>
&lt;ol>
&lt;li>Image Size 📦&lt;/li>
&lt;li>Build Speed 🐢&lt;/li>
&lt;li>Security 🔐&lt;/li>
&lt;/ol>
&lt;p>Image size and build speed ensure that your containers can move through CI/CD and test pipelines easily and efficiently. Security is critical in today&amp;rsquo;s software supply chain, and containers have their own set of security issues. Thankfully, reducing container image size actually can alleviate some security issues in containers.&lt;/p>
&lt;p>&lt;a href="https://wimpysworld.com/posts/creating-production-ready-containers-the-basics">In my Basics article&lt;/a>, I showed you some easy techniques to improve your &lt;code>Dockerfile&lt;/code> using a sample &amp;ldquo;Hello World&amp;rdquo; Node.js application.&lt;/p>
&lt;p>These basics address all three optimisations, though they only scratch the surface.&lt;/p>
&lt;p>Let&amp;rsquo;s look at some more advanced techniques for Container Optimisation.&lt;/p>
&lt;h2 id="alpine-images">Alpine Images&lt;/h2>
&lt;p>The very first thing you&amp;rsquo;ll encounter when looking for techniques to create smaller containers is &lt;a href="https://alpinelinux.org/">Alpine Linux&lt;/a>. Alpine Linux is an open-source project whose goal is to create a bare-bones 🦴 version of Linux that lets developers &amp;ldquo;build from the ground up.&amp;rdquo;&lt;/p>
&lt;h3 id="pros-transitioning-to-alpine-can-be-an-easy-way-to-get-a-smaller-container">Pros: Transitioning to Alpine can be an easy way to get a smaller container&lt;/h3>
&lt;p>Reducing image size with Alpine can be incredibly simple - under the right circumstances. For some apps, it&amp;rsquo;s as easy as changing the base image in your &lt;code>Dockerfile&lt;/code>:&lt;/p>
&lt;h4 id="from">FROM&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f00">FROM&lt;/span>&lt;span style="color:#87ceeb"> node:16.2.0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="to">TO&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f00">FROM&lt;/span>&lt;span style="color:#87ceeb"> node:16.2.0-alpine&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>When we build the new image, we see that the old image was 856MB and the new one is 114MB 🎉&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>REPOSITORY TAG IMAGE ID CREATED SIZE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cotw-node-alpine latest 2cc7b4a7b09c 2 minutes ago 114MB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cotw-node latest 873fb9fca53a 3 days ago 856MB
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Easy, right? Not so fast.&lt;/p>
&lt;h3 id="cons-using-alpine-images-can-lead-to-build-problems-now-and-in-the-future">Cons: Using Alpine images can lead to build problems, now and in the future&lt;/h3>
&lt;p>There are some not-so-obvious gotchas with using Alpine images that don&amp;rsquo;t crop up in our super simple example application, such as:&lt;/p>
&lt;h4 id="you-have-to-install-everything">You have to install everything&lt;/h4>
&lt;p>Those tiny base images have to sacrifice something, right? Alpine users will be installing everything they need, right down to time-zone data or development tools. You won&amp;rsquo;t need your development tools for your production image, most likely, but for most developers, the thought of a server without &lt;code>curl&lt;/code> or &lt;code>vim&lt;/code> is a bridge too far.&lt;/p>
&lt;h4 id="different-compilers-and-package-managers">Different compilers and package managers&lt;/h4>
&lt;p>You&amp;rsquo;ll also be installing any dependencies with the Alpine Package Keeper tool (&lt;code>apk&lt;/code>) instead of the more familiar &lt;code>apt&lt;/code> or &lt;code>rpm&lt;/code>. The differences are small but can trip up unsuspecting developers.&lt;/p>
&lt;h4 id="fewer-examples-less-documentation">Fewer examples; less documentation&lt;/h4>
&lt;p>Finally, while Alpine has been around for nine-plus years, it is and likely always will be a smaller and more specialised user base than established Linux distributions such as Ubuntu and Debian. To wit, at the time of this writing the &lt;code>alpine&lt;/code> tag on StackOverflow has just &lt;a href="https://stackoverflow.com/questions/tagged/alpine">1,280 questions&lt;/a>, compared with &lt;a href="https://stackoverflow.com/questions/tagged/ubuntu">over 54,000 for Ubuntu&lt;/a>.&lt;/p>
&lt;h2 id="multi-stage-builds">Multi-stage builds&lt;/h2>
&lt;p>The next tactic you are likely to encounter when searching for ways to reduce Docker image sizes is multi-stage 🏗 builds. This tactic, &lt;a href="https://docs.docker.com/develop/develop-images/multistage-build/">recommended by Docker and many in the Docker community&lt;/a>, is essentially building the image twice. The first set of commands builds your base application image, all things included. The second set of commands builds an image off of that base image, taking only what&amp;rsquo;s needed and leaving out anything that&amp;rsquo;s not.&lt;/p>
&lt;p>With a multi-stage build, our &lt;code>Dockerfile&lt;/code> would look like this. Notice the two &lt;code>FROM&lt;/code> statements. The first builds the application image; the second copies the necessary files from that image into the second, more production-ready version.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f00">FROM&lt;/span>&lt;span style="color:#87ceeb"> node:16.2.0-alpine as builder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f00">WORKDIR&lt;/span>&lt;span style="color:#87ceeb"> /usr/src/app&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f00">COPY&lt;/span> package*.json ./
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f00">RUN&lt;/span> npm ci
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f00">COPY&lt;/span> app.js ./
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f00">FROM&lt;/span>&lt;span style="color:#87ceeb"> node:16.2.0-alpine&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f00">WORKDIR&lt;/span>&lt;span style="color:#87ceeb"> /usr/src/app&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f00">COPY&lt;/span> --from=builder /usr/src/app .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f00">EXPOSE&lt;/span>&lt;span style="color:#87ceeb"> 3000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f00">USER&lt;/span>&lt;span style="color:#87ceeb"> node&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f00">CMD&lt;/span> [&lt;span style="color:#87ceeb">&amp;#34;node&amp;#34;&lt;/span>,&lt;span style="color:#87ceeb">&amp;#34;app.js&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="pros-dev-and-prod-images-can-be-built-separately">Pros: Dev and Prod images can be built separately&lt;/h3>
&lt;p>When combined with &lt;a href="https://docs.docker.com/compose/">Docker Compose&lt;/a>, this approach gives developers a flexible development environment while reducing bloat in the production images. You can simply use your initial image for dev/test and the final version for production. Multi-stage builds work especially well for Go containers, significantly reducing image size, but also work well for static Node.js and React-type applications.&lt;/p>
&lt;h3 id="cons-added-complexity-use-case-specific">Cons: Added complexity; use-case specific&lt;/h3>
&lt;p>Multi-stage builds are still relatively new 🌱 on the scene. For most developers still new to containers, knowing what to copy over to the final production image and what to leave behind is a major barrier to entry. Further, this pattern can run into challenges.&lt;/p>
&lt;p>Since we&amp;rsquo;re already using an Alpine image, the size savings are relatively minor for our &amp;ldquo;Hello World&amp;rdquo; example. You&amp;rsquo;d expect to see greater gains in a full-blown React or Vue application.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>REPOSITORY TAG IMAGE ID CREATED SIZE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cotw-node-multistage latest 52bc33d14a87 3 minutes ago 114MB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cotw-node-alpine latest 2cc7b4a7b09c 4 days ago 114MB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cotw-node latest 873fb9fca53a 7 days ago 856MB
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="development-tools-and-distroless">Development tools and Distroless&lt;/h2>
&lt;p>There are several tools - and new ones emerging every day - that look to bypass or automate &lt;code>Dockerfile&lt;/code> authoring to make image creation easier. &lt;a href="https://buildpacks.io/">&lt;em>Buildpacks&lt;/em>&lt;/a> are the most mature of these technologies and can be used through tools like &lt;a href="https://buildpacks.io/docs/tools/pack/">Pack&lt;/a> or &lt;a href="https://www.waypointproject.io/plugins/pack">Waypoint&lt;/a>.&lt;/p>
&lt;p>There are builder options from multiple sources - Heroku, Google, and Paketo are common favourites - and each gives you a slightly different developer experience and final image when used.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ pack build cotw-node-bp-google --builder gcr.io/buildpacks/builder:v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pack build cotw-node-bp-heroku --builder heroku/buildpacks:18
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pack build cotw-node-bp-pb-base --builder paketobuildpacks/builder:base
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pack build cotw-node-bp-pb-full --builder paketobuildpacks/builder:full
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="pros-when-they-work-they-work">Pros: When they work, they work&lt;/h3>
&lt;p>In certain instances, Buildpacks can take the pain out of &lt;code>Dockerfile&lt;/code> authoring and just create container images of your application with no fuss. The pack tool is looking for &amp;ldquo;app-like&amp;rdquo; files in your source directory, and automatically figuring out what kind of application is there and how to containerize it. In the case of our Node sample, it sees &lt;code>package.json&lt;/code> and correctly assumes we have a Node.js application.&lt;/p>
&lt;h3 id="cons-when-they-dont">Cons: When they don&amp;rsquo;t…&lt;/h3>
&lt;p>Given the relative newness of this approach for Docker containers, there are a lot of gotchas with Buildpacks. Non-standard applications or operating systems can struggle, and we&amp;rsquo;ve had issues running them successfully on the new Silicon Macbook Pros. The resulting images vary a lot - we saw a range of 200MB to 800MB in our examples - and the results tend to be lower than what you&amp;rsquo;d get with other techniques.&lt;/p>
&lt;h2 id="automate-it-with-slimtoolkit">Automate it with SlimToolKit&lt;/h2>
&lt;p>The &lt;a href="https://slimtoolkit.org/">SlimToolKit&lt;/a> (&lt;em>formerly DockerSlim&lt;/em>) open-source project was created by &lt;a href="https://slim.ai">Slim.AI&lt;/a> CTO &lt;a href="https://twitter.com/kcqon">Kyle Quest&lt;/a> in 2015 as a way to automate container optimisation. Simply download and run &lt;code>slim build &amp;lt;myimage&amp;gt;&lt;/code> and SlimToolKit will examine the image, rebuild it with only the required dependencies, and give you a new image that can be run just like the original.&lt;/p>
&lt;h3 id="pros-its-automatic">Pros: It&amp;rsquo;s automatic&lt;/h3>
&lt;p>SlimToolKit means you can work with whatever base image you&amp;rsquo;d like (say, Ubuntu or Debian) and let SlimToolKit worry about removing unnecessary tools and files en route to production. The best part is that SlimToolKit can be used alongside any of these other techniques. Once tested, it can be integrated into your CI/CD pipeline for automatic container minification, and the reduction in size leads to faster build times and better security.&lt;/p>
&lt;h3 id="cons-steep-learning-curve">Cons: Steep learning curve&lt;/h3>
&lt;p>As with any open-source software, SlimToolKit can take some time to get working, especially for non-trivial applications. It works best for web-style applications, micro-services and APIs that have defined HTTP/HTTPS ports which the sensor can find and use to observe the container internals.&lt;/p>
&lt;p>For best results, spend some time getting to know the various command flags available to tune your image, and &lt;a href="https://github.com/slimtoolkit/examples">take a look at the examples for whatever framework you&amp;rsquo;re using&lt;/a>.&lt;/p>
&lt;h2 id="connecting-with-slimtoolkit">Connecting with SlimToolKit&lt;/h2>
&lt;p>There&amp;rsquo;s an &lt;a href="https://discord.gg/uBttmfyYNB">active Slim.AI Discord channel&lt;/a> full of experts who can help you triage issues as they arise.&lt;/p></description><summary>Advanced techniques for production-ready container best practice</summary></item></channel></rss>